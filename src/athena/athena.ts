// @generated by protobuf-ts 2.11.1 with parameter client_grpc1
// @generated from protobuf file "athena.proto" (package "athena", syntax proto3)
// tslint:disable
import { Empty } from "./google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Response message for ListDeployments RPC
 * Contains the list of active deployments and their details.
 *
 * @generated from protobuf message athena.ListDeploymentsResponse
 */
export interface ListDeploymentsResponse {
    /**
     * List of active deployments with their backlog information.
     *
     * @generated from protobuf field: repeated athena.Deployment deployments = 1
     */
    deployments: Deployment[];
}
/**
 * A single active deployment part of a `ListDeployments` response
 *
 * @generated from protobuf message athena.Deployment
 */
export interface Deployment {
    /**
     * active deployment identifier
     *
     * @generated from protobuf field: string deployment_id = 1
     */
    deploymentId: string;
    /**
     * Backlog of classification responses in this deployment
     *
     * @generated from protobuf field: int32 backlog = 2
     */
    backlog: number;
}
/**
 * The request message containing the image data to classify.
 * Each request represents a batch of images that should be processed within
 * the same deployment context.
 *
 * @generated from protobuf message athena.ClassifyRequest
 */
export interface ClassifyRequest {
    /**
     * Client's unique identifier for this deployment. Responses returned will be
     * sent to a client with a matching deployment_id.
     *
     * @generated from protobuf field: string deployment_id = 1
     */
    deploymentId: string;
    /**
     * Array of images to be classified in this request batch
     * Allows sending multiple images in a single request for efficiency.
     *
     * @generated from protobuf field: repeated athena.ClassificationInput inputs = 2
     */
    inputs: ClassificationInput[];
}
/**
 * A single image within a classification request batch.
 * Contains all necessary metadata and data for classifying one image.
 *
 * @generated from protobuf message athena.ClassificationInput
 */
export interface ClassificationInput {
    /**
     * The affiliate or source system that provided this image
     * Used for tracking, analytics, and routing purposes.
     *
     * @generated from protobuf field: string affiliate = 1
     */
    affiliate: string;
    /**
     * Unique identifier for correlating this input with its response
     * Must be unique within the deployment to properly match responses
     *
     * @generated from protobuf field: string correlation_id = 2
     */
    correlationId: string;
    /**
     * Specifies the encoding/compression format of the image data
     * Allows the server to properly decode the image before classification
     *
     * @generated from protobuf field: athena.RequestEncoding encoding = 3
     */
    encoding: RequestEncoding;
    /**
     * The raw image data bytes in the format specified by encoding
     * Can be compressed or uncompressed based on the encoding field
     *
     * @generated from protobuf field: bytes data = 4
     */
    data: Uint8Array;
    /**
     * The image file format of the data bytes
     *
     * @generated from protobuf field: athena.ImageFormat format = 5
     */
    format: ImageFormat;
    /**
     * Hashes of the image data, can be multiple depending on image processing
     * (e.g. of raw bytes, jpeg image, etc.) but must be for a single image.
     *
     * @generated from protobuf field: repeated athena.ImageHash hashes = 6
     */
    hashes: ImageHash[];
}
/**
 * The response message containing the classification results.
 * Sent back to clients for each processed batch, containing either
 * a global error or individual results for each image in the batch.
 *
 * @generated from protobuf message athena.ClassifyResponse
 */
export interface ClassifyResponse {
    /**
     * Global error affecting the entire batch/request
     * If present, indicates that the entire request failed and no individual
     * image results will be provided
     *
     * @generated from protobuf field: athena.ClassificationError global_error = 1
     */
    globalError?: ClassificationError;
    /**
     * Array of classification results, one for each input image
     * Will be empty if global_error is present
     *
     * @generated from protobuf field: repeated athena.ClassificationOutput outputs = 2
     */
    outputs: ClassificationOutput[];
}
/**
 * Individual classification result for a single image.
 * Contains the correlation ID and classification results for one image.
 *
 * @generated from protobuf message athena.ClassificationOutput
 */
export interface ClassificationOutput {
    /**
     * Matches the correlationId from the corresponding ClassificationInput
     * Allows clients to match responses with their original requests
     *
     * @generated from protobuf field: string correlation_id = 1
     */
    correlationId: string;
    /**
     * Array of all classifications detected for this image
     * Multiple classifications may be returned with different confidence levels
     *
     * @generated from protobuf field: repeated athena.Classification classifications = 2
     */
    classifications: Classification[];
    /**
     * Error information if this specific image classification failed
     * If present, indicates that this particular image could not be processed
     *
     * @generated from protobuf field: athena.ClassificationError error = 3
     */
    error?: ClassificationError;
}
/**
 * A single classification result for an image.
 * Represents one detected category with its confidence score.
 *
 * @generated from protobuf message athena.Classification
 */
export interface Classification {
    /**
     * Human-readable label describing what was classified
     * Examples: "CatA", "CatB", "Indicitive", "Distraction", etc.
     *
     * @generated from protobuf field: string label = 1
     */
    label: string;
    /**
     * Confidence score between 0.0 and 1.0 indicating certainty
     * Higher values indicate greater confidence in the classification
     *
     * @generated from protobuf field: float weight = 2
     */
    weight: number;
}
/**
 * Error information for failed classification attempts.
 * Provides details about why a classification could not be completed.
 *
 * @generated from protobuf message athena.ClassificationError
 */
export interface ClassificationError {
    /**
     * Error code indicating the type of failure
     *
     * @generated from protobuf field: athena.ErrorCode code = 1
     */
    code: ErrorCode;
    /**
     * Human-readable error message providing details about the failure
     *
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * Additional context or details about the error (optional)
     *
     * @generated from protobuf field: string details = 3
     */
    details: string;
}
/**
 * @generated from protobuf message athena.ImageHash
 */
export interface ImageHash {
    /**
     * The hash value of the image data
     *
     * @generated from protobuf field: string value = 1
     */
    value: string;
    /**
     * The type of hash algorithm used to generate the hash value
     *
     * @generated from protobuf field: athena.HashType type = 2
     */
    type: HashType;
}
/**
 * Enumeration of possible classification error codes.
 *
 * @generated from protobuf enum athena.ErrorCode
 */
export enum ErrorCode {
    /**
     * Unknown or unspecified error
     *
     * @generated from protobuf enum value: ERROR_CODE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Image is too large to process
     *
     * @generated from protobuf enum value: ERROR_CODE_IMAGE_TOO_LARGE = 2;
     */
    IMAGE_TOO_LARGE = 2,
    /**
     * Opaque error from the classifier
     *
     * @generated from protobuf enum value: ERROR_CODE_MODEL_ERROR = 3;
     */
    MODEL_ERROR = 3,
    /**
     * Attempt to send data for an affiliate which is not granted to the current
     * client.
     *
     * @generated from protobuf enum value: ERROR_CODE_AFFILIATE_NOT_PERMITTED = 4;
     */
    AFFILIATE_NOT_PERMITTED = 4
}
/**
 * Enumeration of supported image data encoding formats.
 * Determines how the server should interpret the image data bytes.
 *
 * @generated from protobuf enum athena.RequestEncoding
 */
export enum RequestEncoding {
    /**
     * Unspecified encoding. Assumed to be uncompressed.
     *
     * @generated from protobuf enum value: REQUEST_ENCODING_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Uncompressed raw image data (e.g., raw RGB pixels, BMP, etc.)
     *
     * @generated from protobuf enum value: REQUEST_ENCODING_UNCOMPRESSED = 1;
     */
    UNCOMPRESSED = 1,
    /**
     * Brotli-compressed image data for reduced bandwidth usage
     * Server will decompress using Brotli algorithm before processing
     *
     * @generated from protobuf enum value: REQUEST_ENCODING_BROTLI = 2;
     */
    BROTLI = 2
}
/**
 * Enumeration of supported image file formats.
 * Specifies the image file format structure for proper parsing.
 *
 * @generated from protobuf enum athena.ImageFormat
 */
export enum ImageFormat {
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_GIF = 1;
     */
    GIF = 1,
    /**
     * Covers .jpeg, .jpg, .jpe extensions
     *
     * @generated from protobuf enum value: IMAGE_FORMAT_JPEG = 2;
     */
    JPEG = 2,
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_BMP = 3;
     */
    BMP = 3,
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_DIB = 4;
     */
    DIB = 4,
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_PNG = 5;
     */
    PNG = 5,
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_WEBP = 6;
     */
    WEBP = 6,
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_PBM = 7;
     */
    PBM = 7,
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_PGM = 8;
     */
    PGM = 8,
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_PPM = 9;
     */
    PPM = 9,
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_PXM = 10;
     */
    PXM = 10,
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_PNM = 11;
     */
    PNM = 11,
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_PFM = 12;
     */
    PFM = 12,
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_SR = 13;
     */
    SR = 13,
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_RAS = 14;
     */
    RAS = 14,
    /**
     * Covers .tiff, .tif extensions
     *
     * @generated from protobuf enum value: IMAGE_FORMAT_TIFF = 15;
     */
    TIFF = 15,
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_HDR = 16;
     */
    HDR = 16,
    /**
     * @generated from protobuf enum value: IMAGE_FORMAT_PIC = 17;
     */
    PIC = 17,
    /**
     * Raw unsigned 8-bit image data (RGB, C order array)
     *
     * @generated from protobuf enum value: IMAGE_FORMAT_RAW_UINT8 = 18;
     */
    RAW_UINT8 = 18
}
/**
 * @generated from protobuf enum athena.HashType
 */
export enum HashType {
    /**
     * @generated from protobuf enum value: HASH_TYPE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: HASH_TYPE_MD5 = 1;
     */
    MD5 = 1,
    /**
     * @generated from protobuf enum value: HASH_TYPE_SHA1 = 2;
     */
    SHA1 = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class ListDeploymentsResponse$Type extends MessageType<ListDeploymentsResponse> {
    constructor() {
        super("athena.ListDeploymentsResponse", [
            { no: 1, name: "deployments", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Deployment }
        ]);
    }
    create(value?: PartialMessage<ListDeploymentsResponse>): ListDeploymentsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deployments = [];
        if (value !== undefined)
            reflectionMergePartial<ListDeploymentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDeploymentsResponse): ListDeploymentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated athena.Deployment deployments */ 1:
                    message.deployments.push(Deployment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDeploymentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated athena.Deployment deployments = 1; */
        for (let i = 0; i < message.deployments.length; i++)
            Deployment.internalBinaryWrite(message.deployments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message athena.ListDeploymentsResponse
 */
export const ListDeploymentsResponse = new ListDeploymentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Deployment$Type extends MessageType<Deployment> {
    constructor() {
        super("athena.Deployment", [
            { no: 1, name: "deployment_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "backlog", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Deployment>): Deployment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deploymentId = "";
        message.backlog = 0;
        if (value !== undefined)
            reflectionMergePartial<Deployment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Deployment): Deployment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string deployment_id */ 1:
                    message.deploymentId = reader.string();
                    break;
                case /* int32 backlog */ 2:
                    message.backlog = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Deployment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string deployment_id = 1; */
        if (message.deploymentId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.deploymentId);
        /* int32 backlog = 2; */
        if (message.backlog !== 0)
            writer.tag(2, WireType.Varint).int32(message.backlog);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message athena.Deployment
 */
export const Deployment = new Deployment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClassifyRequest$Type extends MessageType<ClassifyRequest> {
    constructor() {
        super("athena.ClassifyRequest", [
            { no: 1, name: "deployment_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "inputs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ClassificationInput }
        ]);
    }
    create(value?: PartialMessage<ClassifyRequest>): ClassifyRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deploymentId = "";
        message.inputs = [];
        if (value !== undefined)
            reflectionMergePartial<ClassifyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClassifyRequest): ClassifyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string deployment_id */ 1:
                    message.deploymentId = reader.string();
                    break;
                case /* repeated athena.ClassificationInput inputs */ 2:
                    message.inputs.push(ClassificationInput.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClassifyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string deployment_id = 1; */
        if (message.deploymentId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.deploymentId);
        /* repeated athena.ClassificationInput inputs = 2; */
        for (let i = 0; i < message.inputs.length; i++)
            ClassificationInput.internalBinaryWrite(message.inputs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message athena.ClassifyRequest
 */
export const ClassifyRequest = new ClassifyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClassificationInput$Type extends MessageType<ClassificationInput> {
    constructor() {
        super("athena.ClassificationInput", [
            { no: 1, name: "affiliate", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "correlation_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "encoding", kind: "enum", T: () => ["athena.RequestEncoding", RequestEncoding, "REQUEST_ENCODING_"] },
            { no: 4, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "format", kind: "enum", T: () => ["athena.ImageFormat", ImageFormat, "IMAGE_FORMAT_"] },
            { no: 6, name: "hashes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ImageHash }
        ]);
    }
    create(value?: PartialMessage<ClassificationInput>): ClassificationInput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.affiliate = "";
        message.correlationId = "";
        message.encoding = 0;
        message.data = new Uint8Array(0);
        message.format = 0;
        message.hashes = [];
        if (value !== undefined)
            reflectionMergePartial<ClassificationInput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClassificationInput): ClassificationInput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string affiliate */ 1:
                    message.affiliate = reader.string();
                    break;
                case /* string correlation_id */ 2:
                    message.correlationId = reader.string();
                    break;
                case /* athena.RequestEncoding encoding */ 3:
                    message.encoding = reader.int32();
                    break;
                case /* bytes data */ 4:
                    message.data = reader.bytes();
                    break;
                case /* athena.ImageFormat format */ 5:
                    message.format = reader.int32();
                    break;
                case /* repeated athena.ImageHash hashes */ 6:
                    message.hashes.push(ImageHash.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClassificationInput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string affiliate = 1; */
        if (message.affiliate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.affiliate);
        /* string correlation_id = 2; */
        if (message.correlationId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.correlationId);
        /* athena.RequestEncoding encoding = 3; */
        if (message.encoding !== 0)
            writer.tag(3, WireType.Varint).int32(message.encoding);
        /* bytes data = 4; */
        if (message.data.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.data);
        /* athena.ImageFormat format = 5; */
        if (message.format !== 0)
            writer.tag(5, WireType.Varint).int32(message.format);
        /* repeated athena.ImageHash hashes = 6; */
        for (let i = 0; i < message.hashes.length; i++)
            ImageHash.internalBinaryWrite(message.hashes[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message athena.ClassificationInput
 */
export const ClassificationInput = new ClassificationInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClassifyResponse$Type extends MessageType<ClassifyResponse> {
    constructor() {
        super("athena.ClassifyResponse", [
            { no: 1, name: "global_error", kind: "message", T: () => ClassificationError },
            { no: 2, name: "outputs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ClassificationOutput }
        ]);
    }
    create(value?: PartialMessage<ClassifyResponse>): ClassifyResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.outputs = [];
        if (value !== undefined)
            reflectionMergePartial<ClassifyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClassifyResponse): ClassifyResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* athena.ClassificationError global_error */ 1:
                    message.globalError = ClassificationError.internalBinaryRead(reader, reader.uint32(), options, message.globalError);
                    break;
                case /* repeated athena.ClassificationOutput outputs */ 2:
                    message.outputs.push(ClassificationOutput.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClassifyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* athena.ClassificationError global_error = 1; */
        if (message.globalError)
            ClassificationError.internalBinaryWrite(message.globalError, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated athena.ClassificationOutput outputs = 2; */
        for (let i = 0; i < message.outputs.length; i++)
            ClassificationOutput.internalBinaryWrite(message.outputs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message athena.ClassifyResponse
 */
export const ClassifyResponse = new ClassifyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClassificationOutput$Type extends MessageType<ClassificationOutput> {
    constructor() {
        super("athena.ClassificationOutput", [
            { no: 1, name: "correlation_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "classifications", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Classification },
            { no: 3, name: "error", kind: "message", T: () => ClassificationError }
        ]);
    }
    create(value?: PartialMessage<ClassificationOutput>): ClassificationOutput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.correlationId = "";
        message.classifications = [];
        if (value !== undefined)
            reflectionMergePartial<ClassificationOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClassificationOutput): ClassificationOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string correlation_id */ 1:
                    message.correlationId = reader.string();
                    break;
                case /* repeated athena.Classification classifications */ 2:
                    message.classifications.push(Classification.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* athena.ClassificationError error */ 3:
                    message.error = ClassificationError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClassificationOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string correlation_id = 1; */
        if (message.correlationId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.correlationId);
        /* repeated athena.Classification classifications = 2; */
        for (let i = 0; i < message.classifications.length; i++)
            Classification.internalBinaryWrite(message.classifications[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* athena.ClassificationError error = 3; */
        if (message.error)
            ClassificationError.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message athena.ClassificationOutput
 */
export const ClassificationOutput = new ClassificationOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Classification$Type extends MessageType<Classification> {
    constructor() {
        super("athena.Classification", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "weight", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Classification>): Classification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.label = "";
        message.weight = 0;
        if (value !== undefined)
            reflectionMergePartial<Classification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Classification): Classification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* float weight */ 2:
                    message.weight = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Classification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* float weight = 2; */
        if (message.weight !== 0)
            writer.tag(2, WireType.Bit32).float(message.weight);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message athena.Classification
 */
export const Classification = new Classification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClassificationError$Type extends MessageType<ClassificationError> {
    constructor() {
        super("athena.ClassificationError", [
            { no: 1, name: "code", kind: "enum", T: () => ["athena.ErrorCode", ErrorCode, "ERROR_CODE_"] },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "details", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ClassificationError>): ClassificationError {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.message = "";
        message.details = "";
        if (value !== undefined)
            reflectionMergePartial<ClassificationError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClassificationError): ClassificationError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* athena.ErrorCode code */ 1:
                    message.code = reader.int32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* string details */ 3:
                    message.details = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClassificationError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* athena.ErrorCode code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* string details = 3; */
        if (message.details !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.details);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message athena.ClassificationError
 */
export const ClassificationError = new ClassificationError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageHash$Type extends MessageType<ImageHash> {
    constructor() {
        super("athena.ImageHash", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["athena.HashType", HashType, "HASH_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<ImageHash>): ImageHash {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = "";
        message.type = 0;
        if (value !== undefined)
            reflectionMergePartial<ImageHash>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ImageHash): ImageHash {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                case /* athena.HashType type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ImageHash, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        /* athena.HashType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message athena.ImageHash
 */
export const ImageHash = new ImageHash$Type();
/**
 * @generated ServiceType for protobuf service athena.ClassifierService
 */
export const ClassifierService = new ServiceType("athena.ClassifierService", [
    { name: "Classify", serverStreaming: true, clientStreaming: true, options: {}, I: ClassifyRequest, O: ClassifyResponse },
    { name: "ListDeployments", options: {}, I: Empty, O: ListDeploymentsResponse }
]);
