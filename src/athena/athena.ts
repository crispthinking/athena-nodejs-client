// @generated by protobuf-ts 2.11.1 with parameter client_grpc1
// @generated from protobuf file "athena.proto" (package "athena", syntax proto3)
// tslint:disable
import { Empty } from './google/protobuf/empty';
import { ServiceType } from '@protobuf-ts/runtime-rpc';
import type { BinaryWriteOptions } from '@protobuf-ts/runtime';
import type { IBinaryWriter } from '@protobuf-ts/runtime';
import { WireType } from '@protobuf-ts/runtime';
import type { BinaryReadOptions } from '@protobuf-ts/runtime';
import type { IBinaryReader } from '@protobuf-ts/runtime';
import { UnknownFieldHandler } from '@protobuf-ts/runtime';
import type { PartialMessage } from '@protobuf-ts/runtime';
import { reflectionMergePartial } from '@protobuf-ts/runtime';
import { MessageType } from '@protobuf-ts/runtime';
/**
 * Response message for ListDeployments RPC
 * Contains the list of active deployments and their details.
 *
 * @generated from protobuf message athena.ListDeploymentsResponse
 */
export interface ListDeploymentsResponse {
  /**
   * List of active deployments with their backlog information.
   *
   * @generated from protobuf field: repeated athena.Deployment deployments = 1
   */
  deployments: Deployment[];
}
/**
 * A single active deployment part of a `ListDeployments` response
 *
 * @generated from protobuf message athena.Deployment
 */
export interface Deployment {
  /**
   * active deployment identifier
   *
   * @generated from protobuf field: string deployment_id = 1
   */
  deploymentId: string;
  /**
   * Backlog of classification responses in this deployment
   *
   * @generated from protobuf field: int32 backlog = 2
   */
  backlog: number;
}
/**
 * The request message containing the image data to classify.
 * Each request represents a batch of images that should be processed within
 * the same deployment context.
 *
 * @generated from protobuf message athena.ClassifyRequest
 */
export interface ClassifyRequest {
  /**
   * Client's unique identifier for this deployment. Responses returned will be
   * sent to a client with a matching deployment_id.
   *
   * @generated from protobuf field: string deployment_id = 1
   */
  deploymentId: string;
  /**
   * Array of images to be classified in this request batch
   * Allows sending multiple images in a single request for efficiency.
   *
   * @generated from protobuf field: repeated athena.ClassificationInput inputs = 2
   */
  inputs: ClassificationInput[];
}
/**
 * A single image within a classification request batch.
 * Contains all necessary metadata and data for classifying one image.
 *
 * @generated from protobuf message athena.ClassificationInput
 */
export interface ClassificationInput {
  /**
   * The affiliate or source system that provided this image
   * Used for tracking, analytics, and routing purposes.
   *
   * @generated from protobuf field: string affiliate = 1
   */
  affiliate: string;
  /**
   * Unique identifier for correlating this input with its response
   * Must be unique within the deployment to properly match responses
   *
   * @generated from protobuf field: string correlation_id = 2
   */
  correlationId: string;
  /**
   * Specifies the encoding/compression format of the image data
   * Allows the server to properly decode the image before classification
   *
   * @generated from protobuf field: athena.RequestEncoding encoding = 3
   */
  encoding: RequestEncoding;
  /**
   * The raw image data bytes in the format specified by encoding
   * Can be compressed or uncompressed based on the encoding field
   *
   * @generated from protobuf field: bytes data = 4
   */
  data: Uint8Array;
  /**
   * The image file format of the data bytes
   *
   * @generated from protobuf field: athena.ImageFormat format = 5
   */
  format: ImageFormat;
  /**
   * Hashes of the image data, can be multiple depending on image processing
   * (e.g. of raw bytes, jpeg image, etc.) but must be for a single image.
   *
   * @generated from protobuf field: repeated athena.ImageHash hashes = 6
   */
  hashes: ImageHash[];
}
/**
 * The response message containing the classification results.
 * Sent back to clients for each processed batch, containing either
 * a global error or individual results for each image in the batch.
 *
 * @generated from protobuf message athena.ClassifyResponse
 */
export interface ClassifyResponse {
  /**
   * Global error affecting the entire batch/request
   * If present, indicates that the entire request failed and no individual
   * image results will be provided
   *
   * @generated from protobuf field: athena.ClassificationError global_error = 1
   */
  globalError?: ClassificationError;
  /**
   * Array of classification results, one for each input image
   * Will be empty if global_error is present
   *
   * @generated from protobuf field: repeated athena.ClassificationOutput outputs = 2
   */
  outputs: ClassificationOutput[];
}
/**
 * Individual classification result for a single image.
 * Contains the correlation ID and classification results for one image.
 *
 * @generated from protobuf message athena.ClassificationOutput
 */
export interface ClassificationOutput {
  /**
   * Matches the correlationId from the corresponding ClassificationInput
   * Allows clients to match responses with their original requests
   *
   * @generated from protobuf field: string correlation_id = 1
   */
  correlationId: string;
  /**
   * Array of all classifications detected for this image
   * Multiple classifications may be returned with different confidence levels
   *
   * @generated from protobuf field: repeated athena.Classification classifications = 2
   */
  classifications: Classification[];
  /**
   * Error information if this specific image classification failed
   * If present, indicates that this particular image could not be processed
   *
   * @generated from protobuf field: athena.ClassificationError error = 3
   */
  error?: ClassificationError;
}
/**
 * A single classification result for an image.
 * Represents one detected category with its confidence score.
 *
 * @generated from protobuf message athena.Classification
 */
export interface Classification {
  /**
   * Human-readable label describing what was classified
   * Examples: "CatA", "CatB", "Indicitive", "Distraction", etc.
   *
   * @generated from protobuf field: string label = 1
   */
  label: string;
  /**
   * Confidence score between 0.0 and 1.0 indicating certainty
   * Higher values indicate greater confidence in the classification
   *
   * @generated from protobuf field: float weight = 2
   */
  weight: number;
}
/**
 * Error information for failed classification attempts.
 * Provides details about why a classification could not be completed.
 *
 * @generated from protobuf message athena.ClassificationError
 */
export interface ClassificationError {
  /**
   * Error code indicating the type of failure
   *
   * @generated from protobuf field: athena.ErrorCode code = 1
   */
  code: ErrorCode;
  /**
   * Human-readable error message providing details about the failure
   *
   * @generated from protobuf field: string message = 2
   */
  message: string;
  /**
   * Additional context or details about the error (optional)
   *
   * @generated from protobuf field: string details = 3
   */
  details: string;
}
/**
 * @generated from protobuf message athena.ImageHash
 */
export interface ImageHash {
  /**
   * The hash value of the image data
   *
   * @generated from protobuf field: string value = 1
   */
  value: string;
  /**
   * The type of hash algorithm used to generate the hash value
   *
   * @generated from protobuf field: athena.HashType type = 2
   */
  type: HashType;
}
/**
 * Enumeration of possible classification error codes.
 *
 * @generated from protobuf enum athena.ErrorCode
 */
export enum ErrorCode {
  /**
   * Unknown or unspecified error
   *
   * @generated from protobuf enum value: ERROR_CODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * Image is too large to process
   *
   * @generated from protobuf enum value: ERROR_CODE_IMAGE_TOO_LARGE = 2;
   */
  IMAGE_TOO_LARGE = 2,
  /**
   * Opaque error from the classifier
   *
   * @generated from protobuf enum value: ERROR_CODE_MODEL_ERROR = 3;
   */
  MODEL_ERROR = 3,
  /**
   * Attempt to send data for an affiliate which is not granted to the current
   * client.
   *
   * @generated from protobuf enum value: ERROR_CODE_AFFILIATE_NOT_PERMITTED = 4;
   */
  AFFILIATE_NOT_PERMITTED = 4,
}
/**
 * Enumeration of supported image data encoding formats.
 * Determines how the server should interpret the image data bytes.
 *
 * @generated from protobuf enum athena.RequestEncoding
 */
export enum RequestEncoding {
  /**
   * Unspecified encoding. Assumed to be uncompressed.
   *
   * @generated from protobuf enum value: REQUEST_ENCODING_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * Uncompressed raw image data (e.g., raw RGB pixels, BMP, etc.)
   *
   * @generated from protobuf enum value: REQUEST_ENCODING_UNCOMPRESSED = 1;
   */
  UNCOMPRESSED = 1,
  /**
   * Brotli-compressed image data for reduced bandwidth usage
   * Server will decompress using Brotli algorithm before processing
   *
   * @generated from protobuf enum value: REQUEST_ENCODING_BROTLI = 2;
   */
  BROTLI = 2,
}
/**
 * Enumeration of supported image file formats.
 * Specifies the image file format structure for proper parsing.
 *
 * @generated from protobuf enum athena.ImageFormat
 */
export enum ImageFormat {
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_GIF = 1;
   */
  GIF = 1,
  /**
   * Covers .jpeg, .jpg, .jpe extensions
   *
   * @generated from protobuf enum value: IMAGE_FORMAT_JPEG = 2;
   */
  JPEG = 2,
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_BMP = 3;
   */
  BMP = 3,
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_DIB = 4;
   */
  DIB = 4,
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_PNG = 5;
   */
  PNG = 5,
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_WEBP = 6;
   */
  WEBP = 6,
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_PBM = 7;
   */
  PBM = 7,
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_PGM = 8;
   */
  PGM = 8,
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_PPM = 9;
   */
  PPM = 9,
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_PXM = 10;
   */
  PXM = 10,
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_PNM = 11;
   */
  PNM = 11,
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_PFM = 12;
   */
  PFM = 12,
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_SR = 13;
   */
  SR = 13,
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_RAS = 14;
   */
  RAS = 14,
  /**
   * Covers .tiff, .tif extensions
   *
   * @generated from protobuf enum value: IMAGE_FORMAT_TIFF = 15;
   */
  TIFF = 15,
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_HDR = 16;
   */
  HDR = 16,
  /**
   * @generated from protobuf enum value: IMAGE_FORMAT_PIC = 17;
   */
  PIC = 17,
  /**
   * Raw unsigned 8-bit image data (RGB, C order array)
   *
   * @generated from protobuf enum value: IMAGE_FORMAT_RAW_UINT8 = 18;
   */
  RAW_UINT8 = 18,
}
/**
 * @generated from protobuf enum athena.HashType
 */
export enum HashType {
  /**
   * @generated from protobuf enum value: HASH_TYPE_UNKNOWN = 0;
   */
  UNKNOWN = 0,
  /**
   * @generated from protobuf enum value: HASH_TYPE_MD5 = 1;
   */
  MD5 = 1,
  /**
   * @generated from protobuf enum value: HASH_TYPE_SHA1 = 2;
   */
  SHA1 = 2,
}
// @generated message type with reflection information, may provide speed optimized methods
class ListDeploymentsResponse$Type extends MessageType<ListDeploymentsResponse> {
  constructor() {
    super('athena.ListDeploymentsResponse', [
      {
        no: 1,
        name: 'deployments',
        kind: 'message',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => Deployment,
      },
    ]);
  }
  create(
    value?: PartialMessage<ListDeploymentsResponse>,
  ): ListDeploymentsResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.deployments = [];
    if (value !== undefined)
      reflectionMergePartial<ListDeploymentsResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListDeploymentsResponse,
  ): ListDeploymentsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated athena.Deployment deployments */ 1:
          message.deployments.push(
            Deployment.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ListDeploymentsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated athena.Deployment deployments = 1; */
    for (let i = 0; i < message.deployments.length; i++)
      Deployment.internalBinaryWrite(
        message.deployments[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message athena.ListDeploymentsResponse
 */
export const ListDeploymentsResponse = new ListDeploymentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Deployment$Type extends MessageType<Deployment> {
  constructor() {
    super('athena.Deployment', [
      {
        no: 1,
        name: 'deployment_id',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: 'backlog', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<Deployment>): Deployment {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.deploymentId = '';
    message.backlog = 0;
    if (value !== undefined)
      reflectionMergePartial<Deployment>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Deployment,
  ): Deployment {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string deployment_id */ 1:
          message.deploymentId = reader.string();
          break;
        case /* int32 backlog */ 2:
          message.backlog = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Deployment,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string deployment_id = 1; */
    if (message.deploymentId !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.deploymentId);
    /* int32 backlog = 2; */
    if (message.backlog !== 0)
      writer.tag(2, WireType.Varint).int32(message.backlog);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message athena.Deployment
 */
export const Deployment = new Deployment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClassifyRequest$Type extends MessageType<ClassifyRequest> {
  constructor() {
    super('athena.ClassifyRequest', [
      {
        no: 1,
        name: 'deployment_id',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: 'inputs',
        kind: 'message',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ClassificationInput,
      },
    ]);
  }
  create(value?: PartialMessage<ClassifyRequest>): ClassifyRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.deploymentId = '';
    message.inputs = [];
    if (value !== undefined)
      reflectionMergePartial<ClassifyRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClassifyRequest,
  ): ClassifyRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string deployment_id */ 1:
          message.deploymentId = reader.string();
          break;
        case /* repeated athena.ClassificationInput inputs */ 2:
          message.inputs.push(
            ClassificationInput.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ClassifyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string deployment_id = 1; */
    if (message.deploymentId !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.deploymentId);
    /* repeated athena.ClassificationInput inputs = 2; */
    for (let i = 0; i < message.inputs.length; i++)
      ClassificationInput.internalBinaryWrite(
        message.inputs[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message athena.ClassifyRequest
 */
export const ClassifyRequest = new ClassifyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClassificationInput$Type extends MessageType<ClassificationInput> {
  constructor() {
    super('athena.ClassificationInput', [
      { no: 1, name: 'affiliate', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'correlation_id',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: 'encoding',
        kind: 'enum',
        T: () => [
          'athena.RequestEncoding',
          RequestEncoding,
          'REQUEST_ENCODING_',
        ],
      },
      { no: 4, name: 'data', kind: 'scalar', T: 12 /*ScalarType.BYTES*/ },
      {
        no: 5,
        name: 'format',
        kind: 'enum',
        T: () => ['athena.ImageFormat', ImageFormat, 'IMAGE_FORMAT_'],
      },
      {
        no: 6,
        name: 'hashes',
        kind: 'message',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ImageHash,
      },
    ]);
  }
  create(value?: PartialMessage<ClassificationInput>): ClassificationInput {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.affiliate = '';
    message.correlationId = '';
    message.encoding = 0;
    message.data = new Uint8Array(0);
    message.format = 0;
    message.hashes = [];
    if (value !== undefined)
      reflectionMergePartial<ClassificationInput>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClassificationInput,
  ): ClassificationInput {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string affiliate */ 1:
          message.affiliate = reader.string();
          break;
        case /* string correlation_id */ 2:
          message.correlationId = reader.string();
          break;
        case /* athena.RequestEncoding encoding */ 3:
          message.encoding = reader.int32();
          break;
        case /* bytes data */ 4:
          message.data = reader.bytes();
          break;
        case /* athena.ImageFormat format */ 5:
          message.format = reader.int32();
          break;
        case /* repeated athena.ImageHash hashes */ 6:
          message.hashes.push(
            ImageHash.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ClassificationInput,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string affiliate = 1; */
    if (message.affiliate !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.affiliate);
    /* string correlation_id = 2; */
    if (message.correlationId !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.correlationId);
    /* athena.RequestEncoding encoding = 3; */
    if (message.encoding !== 0)
      writer.tag(3, WireType.Varint).int32(message.encoding);
    /* bytes data = 4; */
    if (message.data.length)
      writer.tag(4, WireType.LengthDelimited).bytes(message.data);
    /* athena.ImageFormat format = 5; */
    if (message.format !== 0)
      writer.tag(5, WireType.Varint).int32(message.format);
    /* repeated athena.ImageHash hashes = 6; */
    for (let i = 0; i < message.hashes.length; i++)
      ImageHash.internalBinaryWrite(
        message.hashes[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message athena.ClassificationInput
 */
export const ClassificationInput = new ClassificationInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClassifyResponse$Type extends MessageType<ClassifyResponse> {
  constructor() {
    super('athena.ClassifyResponse', [
      {
        no: 1,
        name: 'global_error',
        kind: 'message',
        T: () => ClassificationError,
      },
      {
        no: 2,
        name: 'outputs',
        kind: 'message',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ClassificationOutput,
      },
    ]);
  }
  create(value?: PartialMessage<ClassifyResponse>): ClassifyResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.outputs = [];
    if (value !== undefined)
      reflectionMergePartial<ClassifyResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClassifyResponse,
  ): ClassifyResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* athena.ClassificationError global_error */ 1:
          message.globalError = ClassificationError.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.globalError,
          );
          break;
        case /* repeated athena.ClassificationOutput outputs */ 2:
          message.outputs.push(
            ClassificationOutput.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ClassifyResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* athena.ClassificationError global_error = 1; */
    if (message.globalError)
      ClassificationError.internalBinaryWrite(
        message.globalError,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated athena.ClassificationOutput outputs = 2; */
    for (let i = 0; i < message.outputs.length; i++)
      ClassificationOutput.internalBinaryWrite(
        message.outputs[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message athena.ClassifyResponse
 */
export const ClassifyResponse = new ClassifyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClassificationOutput$Type extends MessageType<ClassificationOutput> {
  constructor() {
    super('athena.ClassificationOutput', [
      {
        no: 1,
        name: 'correlation_id',
        kind: 'scalar',
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: 'classifications',
        kind: 'message',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => Classification,
      },
      { no: 3, name: 'error', kind: 'message', T: () => ClassificationError },
    ]);
  }
  create(value?: PartialMessage<ClassificationOutput>): ClassificationOutput {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.correlationId = '';
    message.classifications = [];
    if (value !== undefined)
      reflectionMergePartial<ClassificationOutput>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClassificationOutput,
  ): ClassificationOutput {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string correlation_id */ 1:
          message.correlationId = reader.string();
          break;
        case /* repeated athena.Classification classifications */ 2:
          message.classifications.push(
            Classification.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* athena.ClassificationError error */ 3:
          message.error = ClassificationError.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.error,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ClassificationOutput,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string correlation_id = 1; */
    if (message.correlationId !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.correlationId);
    /* repeated athena.Classification classifications = 2; */
    for (let i = 0; i < message.classifications.length; i++)
      Classification.internalBinaryWrite(
        message.classifications[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* athena.ClassificationError error = 3; */
    if (message.error)
      ClassificationError.internalBinaryWrite(
        message.error,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message athena.ClassificationOutput
 */
export const ClassificationOutput = new ClassificationOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Classification$Type extends MessageType<Classification> {
  constructor() {
    super('athena.Classification', [
      { no: 1, name: 'label', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'weight', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/ },
    ]);
  }
  create(value?: PartialMessage<Classification>): Classification {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.label = '';
    message.weight = 0;
    if (value !== undefined)
      reflectionMergePartial<Classification>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Classification,
  ): Classification {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string label */ 1:
          message.label = reader.string();
          break;
        case /* float weight */ 2:
          message.weight = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Classification,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string label = 1; */
    if (message.label !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.label);
    /* float weight = 2; */
    if (message.weight !== 0)
      writer.tag(2, WireType.Bit32).float(message.weight);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message athena.Classification
 */
export const Classification = new Classification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClassificationError$Type extends MessageType<ClassificationError> {
  constructor() {
    super('athena.ClassificationError', [
      {
        no: 1,
        name: 'code',
        kind: 'enum',
        T: () => ['athena.ErrorCode', ErrorCode, 'ERROR_CODE_'],
      },
      { no: 2, name: 'message', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'details', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<ClassificationError>): ClassificationError {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.code = 0;
    message.message = '';
    message.details = '';
    if (value !== undefined)
      reflectionMergePartial<ClassificationError>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClassificationError,
  ): ClassificationError {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* athena.ErrorCode code */ 1:
          message.code = reader.int32();
          break;
        case /* string message */ 2:
          message.message = reader.string();
          break;
        case /* string details */ 3:
          message.details = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ClassificationError,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* athena.ErrorCode code = 1; */
    if (message.code !== 0) writer.tag(1, WireType.Varint).int32(message.code);
    /* string message = 2; */
    if (message.message !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.message);
    /* string details = 3; */
    if (message.details !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.details);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message athena.ClassificationError
 */
export const ClassificationError = new ClassificationError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ImageHash$Type extends MessageType<ImageHash> {
  constructor() {
    super('athena.ImageHash', [
      { no: 1, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'type',
        kind: 'enum',
        T: () => ['athena.HashType', HashType, 'HASH_TYPE_'],
      },
    ]);
  }
  create(value?: PartialMessage<ImageHash>): ImageHash {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.value = '';
    message.type = 0;
    if (value !== undefined)
      reflectionMergePartial<ImageHash>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ImageHash,
  ): ImageHash {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string value */ 1:
          message.value = reader.string();
          break;
        case /* athena.HashType type */ 2:
          message.type = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ImageHash,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string value = 1; */
    if (message.value !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.value);
    /* athena.HashType type = 2; */
    if (message.type !== 0) writer.tag(2, WireType.Varint).int32(message.type);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message athena.ImageHash
 */
export const ImageHash = new ImageHash$Type();
/**
 * @generated ServiceType for protobuf service athena.ClassifierService
 */
export const ClassifierService = new ServiceType('athena.ClassifierService', [
  {
    name: 'Classify',
    serverStreaming: true,
    clientStreaming: true,
    options: {},
    I: ClassifyRequest,
    O: ClassifyResponse,
  },
  {
    name: 'ListDeployments',
    options: {},
    I: Empty,
    O: ListDeploymentsResponse,
  },
]);
