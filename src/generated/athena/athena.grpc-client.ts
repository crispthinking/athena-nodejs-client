// @generated by protobuf-ts 2.11.1 with parameter client_grpc1
// @generated from protobuf file "athena/athena.proto" (package "athena", syntax proto3)
// tslint:disable
import { ClassifierService } from "./athena";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { ClassificationOutput } from "./models";
import type { ClassificationInput } from "./models";
import type { ListDeploymentsResponse } from "./models";
import type { Empty } from "../google/protobuf/empty";
import type { ClassifyResponse } from "./models";
import type { ClassifyRequest } from "./models";
import * as grpc from "@grpc/grpc-js";
/**
 * The classifier service definition.
 * Provides image classification capabilities with session-based streaming
 * and client management functionality.
 *
 * @generated from protobuf service athena.ClassifierService
 */
export interface IClassifierServiceClient {
    /**
     * Classify images in a deployment-based streaming context
     * Multiple affiliates can join the same deployment to share responses
     * Supports bidirectional streaming for real-time classification
     *
     * @generated from protobuf rpc: Classify
     */
    classify(metadata: grpc.Metadata, options?: grpc.CallOptions): grpc.ClientDuplexStream<ClassifyRequest, ClassifyResponse>;
    classify(options?: grpc.CallOptions): grpc.ClientDuplexStream<ClassifyRequest, ClassifyResponse>;
    /**
     * Retrieves a list of all active deployment IDs
     * Returns the active deployment_id values that can be used in Classify requests
     * Useful for monitoring and debugging active connections
     *
     * @generated from protobuf rpc: ListDeployments
     */
    listDeployments(input: Empty, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListDeploymentsResponse) => void): grpc.ClientUnaryCall;
    listDeployments(input: Empty, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: ListDeploymentsResponse) => void): grpc.ClientUnaryCall;
    listDeployments(input: Empty, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ListDeploymentsResponse) => void): grpc.ClientUnaryCall;
    listDeployments(input: Empty, callback: (err: grpc.ServiceError | null, value?: ListDeploymentsResponse) => void): grpc.ClientUnaryCall;
    /**
     * Classifies a single image synchronously without deployment context
     * Returns classification results immediately in a single request-response cycle
     * Unlike the streaming Classify method, this operates independently of deployments
     * and does not require session management or deployment coordination
     *
     * Use this for:
     * - Low-throughput, low-latency classification scenarios
     * - Simple one-off image classifications
     * - Applications where immediate synchronous responses are preferred over streaming
     * - Testing and debugging individual image classifications
     *
     * The response will contain either classification results or error information
     * No deployment_id coordination is required or supported
     *
     * @generated from protobuf rpc: ClassifySingle
     */
    classifySingle(input: ClassificationInput, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ClassificationOutput) => void): grpc.ClientUnaryCall;
    classifySingle(input: ClassificationInput, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: ClassificationOutput) => void): grpc.ClientUnaryCall;
    classifySingle(input: ClassificationInput, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: ClassificationOutput) => void): grpc.ClientUnaryCall;
    classifySingle(input: ClassificationInput, callback: (err: grpc.ServiceError | null, value?: ClassificationOutput) => void): grpc.ClientUnaryCall;
}
/**
 * The classifier service definition.
 * Provides image classification capabilities with session-based streaming
 * and client management functionality.
 *
 * @generated from protobuf service athena.ClassifierService
 */
export class ClassifierServiceClient extends grpc.Client implements IClassifierServiceClient {
    private readonly _binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions>;
    constructor(address: string, credentials: grpc.ChannelCredentials, options: grpc.ClientOptions = {}, binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions> = {}) {
        super(address, credentials, options);
        this._binaryOptions = binaryOptions;
    }
    /**
     * Classify images in a deployment-based streaming context
     * Multiple affiliates can join the same deployment to share responses
     * Supports bidirectional streaming for real-time classification
     *
     * @generated from protobuf rpc: Classify
     */
    classify(metadata?: grpc.Metadata | grpc.CallOptions, options?: grpc.CallOptions): grpc.ClientDuplexStream<ClassifyRequest, ClassifyResponse> {
        const method = ClassifierService.methods[0];
        return this.makeBidiStreamRequest<ClassifyRequest, ClassifyResponse>(`/${ClassifierService.typeName}/${method.name}`, (value: ClassifyRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): ClassifyResponse => method.O.fromBinary(value, this._binaryOptions), (metadata as any), options);
    }
    /**
     * Retrieves a list of all active deployment IDs
     * Returns the active deployment_id values that can be used in Classify requests
     * Useful for monitoring and debugging active connections
     *
     * @generated from protobuf rpc: ListDeployments
     */
    listDeployments(input: Empty, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListDeploymentsResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ListDeploymentsResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: ListDeploymentsResponse) => void)): grpc.ClientUnaryCall {
        const method = ClassifierService.methods[1];
        return this.makeUnaryRequest<Empty, ListDeploymentsResponse>(`/${ClassifierService.typeName}/${method.name}`, (value: Empty): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): ListDeploymentsResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * Classifies a single image synchronously without deployment context
     * Returns classification results immediately in a single request-response cycle
     * Unlike the streaming Classify method, this operates independently of deployments
     * and does not require session management or deployment coordination
     *
     * Use this for:
     * - Low-throughput, low-latency classification scenarios
     * - Simple one-off image classifications
     * - Applications where immediate synchronous responses are preferred over streaming
     * - Testing and debugging individual image classifications
     *
     * The response will contain either classification results or error information
     * No deployment_id coordination is required or supported
     *
     * @generated from protobuf rpc: ClassifySingle
     */
    classifySingle(input: ClassificationInput, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ClassificationOutput) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: ClassificationOutput) => void), callback?: ((err: grpc.ServiceError | null, value?: ClassificationOutput) => void)): grpc.ClientUnaryCall {
        const method = ClassifierService.methods[2];
        return this.makeUnaryRequest<ClassificationInput, ClassificationOutput>(`/${ClassifierService.typeName}/${method.name}`, (value: ClassificationInput): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): ClassificationOutput => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
}
